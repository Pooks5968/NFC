\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{xcolor}

\newcommand\TODO[1]{\textcolor{red}{#1}}

\begin{document}
\title{Defense Against W NFC}
\author{Max Feldman \and Stephanie Rogers \and Richard Xia}
\maketitle

\section{Abstract}
1-3 paragraph version of introduction

\section{Introduction}
1-2 page version of paper

Related NFC Technology and Security - authenticating tags rather than users
* MiFare: hardware that allows the locking of data and allows symmetric mutual authentication of users and write protection to defend against reading and writing of the tag (privacy)
* FeliCa: authentication and write protection 
* AFAICT: lock the data (not overwritable), but no authentication!

\section{Background}
describe NFC

Android/permission system

intents

* current apps, what permissions do they use
** characteristics of apps
*** tiny
*** superapps

* threat model
** writing sensitive data
** malicious tags which cause automatic running of apps which can cost money
** eavesdropping
** malware

\section{Related Work}

\section{Analysis of Apps}
* Why analyze
** general coding practices re: NFC
** what practices contribute to vulnerabilities of NFC apps
** As for as we know, no broad analysis of NFC app level stuff
** provide suggestion for NFC app devs (we are in a unique position in that this tech is up and coming)
* static
** trace where data read from NFC tags is ended
** other static tools?
** Beam
** Use of crypto libs
** Overwriting tags- do apps in general 0 out prior data, or not?

* dynamic
** taintdroid
** droidblaze

* manual
** looked at source code
** played with apps
** trace exec paths if possible
** BEAM
*** If you scan an app, it'll take you to the app store
* permission scraping etc

\section{Proposed Solution}
* Goals/non-goals
* architecture
** distributed authentication
*** generalizable to arbitrary inputs to phone?

* Goals

As a user
I want to be able to verify a tag came from a given author
In order to ensure I am not acting on malicious inputs

As a user
I want to be able to keep track of tag authors
In order to expand the scope of tags I can trust

As a user
I want to be able to verify my own tags
In order to ensure use my own tags

As a user
I want to be able to encrypt my own tags
In order to ensure no one else can read my tags

As a user
I want to keep the identities of trusted tag authors correct
In case if good authors go bad

As a user
I want to report malicious tag authors
To warn other users of bad authors

As a tag author
I want to share my key with a user
To prevent others from impersonating me

** integrity
** authentication

* Non goals
** confidentiality of tag data
** ignoring malicious applications
** no central authority
** not ensuring security of key exchange


How to get keys?
* Go to website of tag author you trust, DL their key
* see it for the first time (good info in prompt?)
* add a key repo
* NFC tag (P2P sign)
* No signature: different prompt

Prompts:
* disable all pmopts
* never allow this key?
* allow key once
* allow key always
* allow all keys

* We should alway state why we make any choice

\section{Implementation}
We implemented our authentication system as an Android library that Android developers can include into their projects.
Our data format for secure NDEF tags adds an extra record at the end of an NDEF message which contains a signature of the other NDEF records in the message.
We developed a class for interfacing with secure NDEF tags we call \texttt{SignedNdef}, providing all the necessary methods for securely reading and writing tags.
Android developers can use the API we developed for interfacing with a \texttt{SignedNdef} object, which we designed to closely mimic the existing official Android \texttt{Ndef}\footnote{http://developer.android.com/reference/android/nfc/tech/Ndef.html} object for reading and writing NDEF tags.

On instantiation, a \texttt{SignedNdef} object will attempt to open up the list of authorized keys saved on the Android device.
It provides methods for opening, closing, reading, and writing NDEF-formatted tags by delegating to a private instance of the \texttt{Ndef} class.
In addition, it will automatically enforce the security protocols described earlier.
When reading, it will query the \texttt{KeyManager} to find a public key which matches the signature of the signed Ndef tag.
If it can locate a valid public key which matches the signature, it will transparently return the non-signature records on the tag.
In case of any errors or failure to locate a valid public key, it will throw an exception. \TODO{Actually talk about what happens; key manager, etc}


* implementation
** proof of concept
** recommendations
* key file
* key add/remove
* warnings
* (a duplicate app w/ some functionality but no auth, for demo)
* API
* warning for invalid signature

\section{Evaluation}
* simplicity/overhead for user (warning message?)
* how many apps can benefit from this?
* applicability
** do 3 case studies (examples of applying it to an application)
** do it on github
* How many additional lines of code required for using API?

* (performance (time+space))
* security of this scheme
** bits of security (e.g. signature size)
** assumptions/foundations (e.g. secure key distribution)
** key storage on Android phones can't be tampered with

* LIMITATIONS

* key add/revoke
** app perm to add
** app perm to remove
** done via syscalls, i.e. android holds this
*** some intent?
** some way for app developer to add centralized repo of keys
** automatic get key

* Does phone already have a pub key pair?
* backwards compatibility
** Read NDEF standards and how Android handles them

brainstorm                         works for                           bad
- NDEF record/type for signature   updated os
                                   app viewing finite \# records
- length exclused signature        above                               violates standards
  + above                          app viewing variable \# of records   

\section{Discussion}

\section{Future Work}
* user study, human testing
* overhead imposed by warnings/approvals
** delves into usable security
* compression/optimization
* OS perms, kernel mods to support this

\section{Conclusion}

\section{Acknowledgements}

\section{References}

\end{document}
